<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFUNIXDatagramSocketImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFUNIXDatagramSocketImpl.java</span></div><h1>AFUNIXDatagramSocketImpl.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2021 Christian Kohlsch√ºtter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.FileDescriptor;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocketImpl;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

final class AFUNIXDatagramSocketImpl extends DatagramSocketImpl {
  private final AFUNIXSocketCore core;
<span class="fc" id="L34">  final AncillaryDataSupport ancillaryDataSupport = new AncillaryDataSupport();</span>
<span class="fc" id="L35">  private final AtomicBoolean connected = new AtomicBoolean(false);</span>
<span class="fc" id="L36">  private final AtomicBoolean bound = new AtomicBoolean(false);</span>

<span class="fc" id="L38">  private final AtomicInteger socketTimeout = new AtomicInteger(0);</span>
<span class="fc" id="L39">  private int remotePort = 0;</span>

  AFUNIXDatagramSocketImpl(FileDescriptor fd) throws IOException {
<span class="fc" id="L42">    super();</span>
<span class="fc" id="L43">    this.core = new AFUNIXSocketCore(this, fd, ancillaryDataSupport);</span>
<span class="fc" id="L44">    this.fd = core.fd;</span>
<span class="fc" id="L45">  }</span>

  @Override
  protected void create() throws SocketException {
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L50">      throw new SocketException(&quot;Already closed&quot;);</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">    } else if (fd.valid()) {</span>
<span class="fc" id="L52">      return;</span>
    }
    try {
<span class="fc" id="L55">      NativeUnixSocket.createSocket(fd, NativeUnixSocket.SOCK_DGRAM);</span>
<span class="nc" id="L56">    } catch (SocketException e) {</span>
<span class="nc" id="L57">      throw e;</span>
<span class="nc" id="L58">    } catch (IOException e) {</span>
<span class="nc" id="L59">      throw (SocketException) new SocketException(e.getMessage()).initCause(e);</span>
<span class="fc" id="L60">    }</span>
<span class="fc" id="L61">  }</span>

  @Override
  protected void close() {
<span class="fc" id="L65">    core.runCleaner();</span>
<span class="fc" id="L66">  }</span>

  @Override
  protected void connect(InetAddress address, int port) throws SocketException {
    // not used; see connect(AFUNIXSocketAddress)
<span class="fc" id="L71">  }</span>

  void connect(AFUNIXSocketAddress socketAddress) throws IOException {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">    if (socketAddress == AFUNIXSocketAddress.INTERNAL_DUMMY_CONNECT) { // NOPMD</span>
<span class="nc" id="L75">      return;</span>
    }
<span class="fc" id="L77">    NativeUnixSocket.connect(socketAddress.getBytes(), fd, -1);</span>
<span class="fc" id="L78">    this.remotePort = socketAddress.getPort();</span>
<span class="fc" id="L79">  }</span>

  @Override
  protected void disconnect() {
    try {
<span class="nc" id="L84">      NativeUnixSocket.disconnect(fd);</span>
<span class="nc" id="L85">      connected.set(false);</span>
<span class="nc" id="L86">      this.remotePort = 0;</span>
<span class="nc" id="L87">    } catch (IOException e) {</span>
<span class="nc" id="L88">      e.printStackTrace();</span>
<span class="nc" id="L89">    }</span>
<span class="nc" id="L90">  }</span>

  AFUNIXSocketCore getCore() {
<span class="fc" id="L93">    return core;</span>
  }

  @Override
  protected FileDescriptor getFileDescriptor() {
<span class="fc" id="L98">    return core.fd;</span>
  }

  boolean isClosed() {
<span class="fc" id="L102">    return core.isClosed();</span>
  }

  @Override
  protected void bind(int lport, InetAddress laddr) throws SocketException {
    // not used; see bind(AFUNIXSocketAddress)
<span class="fc" id="L108">  }</span>

  void bind(AFUNIXSocketAddress socketAddress) throws SocketException {
<span class="fc bfc" id="L111" title="All 2 branches covered.">    if (socketAddress == AFUNIXSocketAddress.INTERNAL_DUMMY_BIND) { // NOPMD</span>
<span class="fc" id="L112">      return;</span>
    }
    try {
<span class="fc" id="L115">      NativeUnixSocket.bind(socketAddress.getBytes(), fd, 0);</span>
<span class="fc" id="L116">      this.localPort = socketAddress.getPort();</span>
<span class="nc" id="L117">    } catch (SocketException e) {</span>
<span class="nc" id="L118">      throw e;</span>
<span class="nc" id="L119">    } catch (IOException e) {</span>
<span class="nc" id="L120">      throw (SocketException) new SocketException(e.getMessage()).initCause(e);</span>
<span class="fc" id="L121">    }</span>
<span class="fc" id="L122">  }</span>

  @Override
  protected void receive(DatagramPacket p) throws IOException {
<span class="fc" id="L126">    recv(p, 0);</span>
<span class="fc" id="L127">  }</span>

  private void recv(DatagramPacket p, int options) throws IOException {
<span class="fc" id="L130">    int len = p.getLength();</span>
<span class="fc" id="L131">    FileDescriptor fdesc = core.validFdOrException();</span>

<span class="fc" id="L133">    ByteBuffer datagramPacketBuffer = core.getThreadLocalDirectByteBuffer(len);</span>
<span class="fc" id="L134">    len = Math.min(len, datagramPacketBuffer.capacity());</span>

<span class="fc" id="L136">    ByteBuffer socketAddressBuffer = AFUNIXSocketAddress.SOCKETADDRESS_BUFFER_TL.get();</span>
<span class="fc" id="L137">    int count = NativeUnixSocket.receive(fdesc, datagramPacketBuffer, 0, len, socketAddressBuffer,</span>
<span class="fc" id="L138">        options, ancillaryDataSupport, socketTimeout.get());</span>
<span class="pc bpc" id="L139" title="2 of 4 branches missed.">    if (count &gt; len || count &lt; 0) {</span>
<span class="nc" id="L140">      throw new IllegalStateException();</span>
    }
<span class="fc" id="L142">    datagramPacketBuffer.limit(count);</span>
<span class="fc" id="L143">    datagramPacketBuffer.rewind();</span>
<span class="fc" id="L144">    datagramPacketBuffer.get(p.getData(), p.getOffset(), count);</span>

<span class="fc" id="L146">    p.setLength(count);</span>

<span class="fc" id="L148">    AFUNIXSocketAddress addr = AFUNIXSocketAddress.ofInternal(socketAddressBuffer);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">    p.setAddress(addr == null ? null : addr.getInetAddress());</span>
<span class="fc" id="L150">    p.setPort(remotePort);</span>
<span class="fc" id="L151">  }</span>

  @Override
  protected void send(DatagramPacket p) throws IOException {
<span class="fc" id="L155">    InetAddress addr = p.getAddress();</span>
<span class="fc" id="L156">    ByteBuffer sendToBuf = null;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">    if (addr != null) {</span>
<span class="fc" id="L158">      byte[] addrBytes = AFUNIXInetAddress.unwrapAddress(addr); // NOTE port is not unchecked</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">      if (addrBytes != null) {</span>
<span class="fc" id="L160">        sendToBuf = AFUNIXSocketAddress.SOCKETADDRESS_BUFFER_TL.get();</span>
<span class="fc" id="L161">        NativeUnixSocket.bytesToSockAddrUn(sendToBuf, addrBytes);</span>
      }
    }
<span class="fc" id="L164">    FileDescriptor fdesc = core.validFdOrException();</span>

<span class="fc" id="L166">    int len = p.getLength();</span>
<span class="fc" id="L167">    ByteBuffer datagramPacketBuffer = core.getThreadLocalDirectByteBuffer(len);</span>
<span class="fc" id="L168">    datagramPacketBuffer.clear();</span>
<span class="fc" id="L169">    datagramPacketBuffer.put(p.getData(), p.getOffset(), p.getLength());</span>
<span class="fc" id="L170">    NativeUnixSocket.send(fdesc, datagramPacketBuffer, 0, len, sendToBuf,</span>
        NativeUnixSocket.OPT_NON_BLOCKING, ancillaryDataSupport);
<span class="fc" id="L172">  }</span>

  @Override
  protected int peek(InetAddress i) throws IOException {
<span class="nc" id="L176">    throw new SocketException(&quot;Unsupported operation&quot;);</span>
  }

  @Override
  protected int peekData(DatagramPacket p) throws IOException {
<span class="fc" id="L181">    recv(p, NativeUnixSocket.OPT_PEEK);</span>
<span class="fc" id="L182">    return 0;</span>
  }

  @Override
  protected byte getTTL() throws IOException {
<span class="nc" id="L187">    return (byte) (getTimeToLive() &amp; 0xFF);</span>
  }

  @Override
  protected void setTTL(byte ttl) throws IOException {
    // ignored
<span class="nc" id="L193">  }</span>

  @Override
  protected int getTimeToLive() throws IOException {
<span class="nc" id="L197">    return 0;</span>
  }

  @Override
  protected void setTimeToLive(int ttl) throws IOException {
    // ignored
<span class="nc" id="L203">  }</span>

  @Override
  protected void join(InetAddress inetaddr) throws IOException {
<span class="nc" id="L207">    throw new SocketException(&quot;Unsupported&quot;);</span>
  }

  @Override
  protected void leave(InetAddress inetaddr) throws IOException {
<span class="nc" id="L212">    throw new SocketException(&quot;Unsupported&quot;);</span>
  }

  @Override
  protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
<span class="nc" id="L217">    throw new SocketException(&quot;Unsupported&quot;);</span>
  }

  @Override
  protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
<span class="nc" id="L222">    throw new SocketException(&quot;Unsupported&quot;);</span>
  }

  @Override
  public Object getOption(int optID) throws SocketException {
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L228">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }

<span class="fc" id="L231">    FileDescriptor fdesc = core.validFdOrException();</span>
<span class="fc" id="L232">    return AFUNIXSocketImpl.getOptionDefault(fdesc, optID, socketTimeout);</span>
  }

  @Override
  public void setOption(int optID, Object value) throws SocketException {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L238">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }

<span class="fc" id="L241">    FileDescriptor fdesc = core.validFdOrException();</span>
<span class="fc" id="L242">    AFUNIXSocketImpl.setOptionDefault(fdesc, optID, value, socketTimeout);</span>
<span class="fc" id="L243">  }</span>

  AFUNIXSocketCredentials getPeerCredentials() throws IOException {
<span class="fc" id="L246">    return NativeUnixSocket.peerCredentials(fd, new AFUNIXSocketCredentials());</span>
  }

  AFUNIXSocketAddress receive(ByteBuffer dst) throws IOException {
<span class="nc" id="L250">    return core.receive(dst);</span>
  }

  int send(ByteBuffer src, SocketAddress target) throws IOException {
<span class="nc" id="L254">    return core.write(src, target, 0);</span>
  }

  int read(ByteBuffer dst, ByteBuffer socketAddressBuffer) throws IOException {
<span class="fc" id="L258">    return core.read(dst, socketAddressBuffer, 0);</span>
  }

  int write(ByteBuffer src) throws IOException {
<span class="fc" id="L262">    return core.write(src);</span>
  }

  boolean isConnected() {
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">    if (connected.get()) {</span>
<span class="nc" id="L267">      return true;</span>
    }
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L270">      return false;</span>
    }
<span class="fc bfc" id="L272" title="All 2 branches covered.">    if (core.isConnected(false)) {</span>
<span class="fc" id="L273">      connected.set(true);</span>
<span class="fc" id="L274">      return true;</span>
    }
<span class="fc" id="L276">    return false;</span>
  }

  boolean isBound() {
<span class="fc bfc" id="L280" title="All 2 branches covered.">    if (bound.get()) {</span>
<span class="fc" id="L281">      return true;</span>
    }
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L284">      return false;</span>
    }
<span class="fc bfc" id="L286" title="All 2 branches covered.">    if (core.isConnected(true)) {</span>
<span class="fc" id="L287">      bound.set(true);</span>
<span class="fc" id="L288">      return true;</span>
    }
<span class="fc" id="L290">    return false;</span>
  }

  void updatePorts(int local, int remote) {
<span class="fc" id="L294">    this.localPort = local;</span>
<span class="fc" id="L295">    this.remotePort = remote;</span>
<span class="fc" id="L296">  }</span>

  AFUNIXSocketAddress getLocalSocketAddress() {
<span class="nc" id="L299">    return AFUNIXSocketAddress.getSocketAddress(getFileDescriptor(), false, localPort);</span>
  }

  AFUNIXSocketAddress getRemoteSocketAddress() {
<span class="fc" id="L303">    return AFUNIXSocketAddress.getSocketAddress(getFileDescriptor(), true, remotePort);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>