<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFUNIXRMISocketFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-rmi</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix.rmi</a> &gt; <span class="el_source">AFUNIXRMISocketFactory.java</span></div><h1>AFUNIXRMISocketFactory.java</h1><pre class="source lang-java linenums">/**
 * junixsocket
 *
 * Copyright 2009-2021 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix.rmi;

import java.io.Closeable;
import java.io.Externalizable;
import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Files;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMIServerSocketFactory;
import java.rmi.server.RMISocketFactory;
import java.util.BitSet;
import java.util.HashMap;
import java.util.Map;

import org.newsclub.net.unix.AFUNIXServerSocket;
import org.newsclub.net.unix.AFUNIXSocket;
import org.newsclub.net.unix.AFUNIXSocketAddress;
import org.newsclub.net.unix.AFUNIXSocketCredentials;
import org.newsclub.net.unix.rmi.ShutdownHookSupport.ShutdownHook;
import org.newsclub.net.unix.rmi.ShutdownHookSupport.ShutdownThread;

/**
 * An {@link RMISocketFactory} that supports {@link AFUNIXSocket}s.
 * 
 * @author Christian Kohlschütter
 */
public class AFUNIXRMISocketFactory extends RMISocketFactory implements Externalizable, Closeable,
    ShutdownHook {
  static final String DEFAULT_SOCKET_FILE_PREFIX = &quot;&quot;;
  static final String DEFAULT_SOCKET_FILE_SUFFIX = &quot;.rmi&quot;;

  private static final long serialVersionUID = 1L;

  private RMIClientSocketFactory defaultClientFactory;
  private RMIServerSocketFactory defaultServerFactory;

  private File socketDir;
  private AFUNIXNaming naming;

  private String socketPrefix;
  private String socketSuffix;

<span class="fc" id="L67">  private AFUNIXRMIService rmiService = null;</span>

<span class="fc" id="L69">  private Map&lt;HostAndPort, AFUNIXSocketCredentials&gt; credentials = new HashMap&lt;&gt;();</span>

<span class="fc" id="L71">  private final BitSet openServerPorts = new BitSet();</span>

  /**
   * Constructor required per definition.
   * 
   * @see RMISocketFactory
   */
  public AFUNIXRMISocketFactory() {
<span class="fc" id="L79">    super();</span>
<span class="fc" id="L80">    closeUponRuntimeShutdown();</span>
<span class="fc" id="L81">  }</span>

  public AFUNIXRMISocketFactory(final AFUNIXNaming naming, final File socketDir)
      throws IOException {
<span class="nc" id="L85">    this(naming, socketDir, DefaultRMIClientSocketFactory.getInstance(),</span>
<span class="nc" id="L86">        DefaultRMIServerSocketFactory.getInstance());</span>
<span class="nc" id="L87">  }</span>

  public AFUNIXRMISocketFactory(final AFUNIXNaming naming, final File socketDir,
      final RMIClientSocketFactory defaultClientFactory,
      final RMIServerSocketFactory defaultServerFactory) throws IOException {
<span class="nc" id="L92">    this(naming, socketDir, defaultClientFactory, defaultServerFactory, null, null);</span>
<span class="nc" id="L93">  }</span>

  public AFUNIXRMISocketFactory(final AFUNIXNaming naming, final File socketDir,
      final RMIClientSocketFactory defaultClientFactory,
      final RMIServerSocketFactory defaultServerFactory, final String socketPrefix,
      final String socketSuffix) throws IOException {
<span class="fc" id="L99">    super();</span>
<span class="fc" id="L100">    this.naming = naming;</span>
<span class="fc" id="L101">    this.socketDir = socketDir;</span>
<span class="fc" id="L102">    this.defaultClientFactory = defaultClientFactory;</span>
<span class="fc" id="L103">    this.defaultServerFactory = defaultServerFactory;</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">    this.socketPrefix = socketPrefix == null ? DEFAULT_SOCKET_FILE_PREFIX : socketPrefix;</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">    this.socketSuffix = socketSuffix == null ? DEFAULT_SOCKET_FILE_SUFFIX : socketSuffix;</span>

<span class="fc" id="L107">    closeUponRuntimeShutdown();</span>
<span class="fc" id="L108">  }</span>

  private boolean isPlainFileSocket() {
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">    return (naming.getRegistryPort() == AFUNIXRMIPorts.PLAIN_FILE_SOCKET);</span>
  }

  void deleteStaleFiles() {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">    if (isPlainFileSocket()) {</span>
      // nothing to do
<span class="nc" id="L117">      return;</span>
    }
<span class="fc" id="L119">    File sd = socketDir;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">    if (sd == null) {</span>
<span class="nc" id="L121">      return;</span>
    }
<span class="fc" id="L123">    File[] files = sd.listFiles(new FilenameFilter() {</span>
      @Override
      public boolean accept(File dir, String name) {
<span class="nc bnc" id="L126" title="All 4 branches missed.">        return name.startsWith(socketPrefix) &amp;&amp; name.endsWith(socketSuffix);</span>
      }
    });
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">    if (files == null) {</span>
<span class="nc" id="L130">      return;</span>
    }
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">    for (File f : files) {</span>
<span class="nc" id="L133">      String name = f.getName();</span>
<span class="nc" id="L134">      String portName = name.substring(0, name.length() - socketSuffix.length()).substring(</span>
<span class="nc" id="L135">          socketPrefix.length());</span>

      int port;
      try {
<span class="nc" id="L139">        port = Integer.parseInt(portName);</span>
<span class="nc" id="L140">      } catch (Exception e) {</span>
<span class="nc" id="L141">        port = -1;</span>
<span class="nc" id="L142">      }</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">      if (port &gt;= AFUNIXRMIPorts.AF_PORT_BASE) {</span>
<span class="nc" id="L144">        boolean connected = false;</span>
<span class="nc" id="L145">        try (Socket s = this.createSocket(&quot;&quot;, port)) {</span>
<span class="nc" id="L146">          connected = true;</span>
<span class="nc" id="L147">        } catch (IOException e) {</span>
          // connection refused or something else
<span class="nc" id="L149">        }</span>

<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (!connected) {</span>
          try {
<span class="nc" id="L153">            Files.delete(f.toPath());</span>
<span class="nc" id="L154">          } catch (IOException e) {</span>
            // ignore
<span class="nc" id="L156">          }</span>
        }
      }
    }
<span class="fc" id="L160">  }</span>

  private void closeUponRuntimeShutdown() {
<span class="fc" id="L163">    ShutdownHookSupport.addWeakShutdownHook(this);</span>
<span class="fc" id="L164">  }</span>

  @Override
  public int hashCode() {
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">    return socketDir == null ? super.hashCode() : socketDir.hashCode();</span>
  }

  @Override
  public boolean equals(Object other) {
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">    if (!(other instanceof AFUNIXRMISocketFactory)) {</span>
<span class="nc" id="L174">      return false;</span>
    }
<span class="fc" id="L176">    AFUNIXRMISocketFactory sf = (AFUNIXRMISocketFactory) other;</span>
<span class="fc" id="L177">    return sf.socketDir.equals(socketDir);</span>
  }

  @SuppressWarnings(&quot;resource&quot;)
  @Override
  public Socket createSocket(String host, int port) throws IOException {
<span class="fc" id="L183">    final RMIClientSocketFactory cf = defaultClientFactory;</span>
<span class="pc bpc" id="L184" title="3 of 4 branches missed.">    if (cf != null &amp;&amp; port &lt; AFUNIXRMIPorts.AF_PORT_BASE) {</span>
<span class="nc" id="L185">      return cf.createSocket(host, port);</span>
    }

<span class="fc" id="L188">    final AFUNIXSocketAddress addr = new AFUNIXSocketAddress(getFile(port), port);</span>

<span class="fc" id="L190">    final AFUNIXSocket socket = AFUNIXSocket.newInstance();</span>
<span class="fc" id="L191">    socket.connect(addr);</span>
<span class="fc" id="L192">    AFUNIXSocketCredentials creds = socket.getPeerCredentials();</span>

<span class="fc" id="L194">    final HostAndPort hap = new HostAndPort(host, port);</span>
<span class="fc" id="L195">    synchronized (credentials) {</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">      if (credentials.put(hap, creds) != null) {</span>
        // unexpected
      }
<span class="fc" id="L199">    }</span>
<span class="fc" id="L200">    socket.addCloseable(new Closeable() {</span>
      @Override
      public void close() throws IOException {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (credentials == null) {</span>
<span class="nc" id="L204">          return;</span>
        }
<span class="fc" id="L206">        synchronized (credentials) {</span>
<span class="fc" id="L207">          credentials.remove(hap);</span>
<span class="fc" id="L208">        }</span>
<span class="fc" id="L209">      }</span>
    });
<span class="fc" id="L211">    return socket;</span>
  }

  public File getSocketDir() {
<span class="nc" id="L215">    return socketDir;</span>
  }

  File getFile(int port) {
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">    if (isPlainFileSocket()) {</span>
<span class="nc" id="L220">      return socketDir;</span>
    } else {
<span class="fc" id="L222">      return new File(socketDir, socketPrefix + port + socketSuffix);</span>
    }
  }

  void deleteSocketFile(int port) {
    try {
<span class="fc" id="L228">      Files.delete(getFile(port).toPath());</span>
<span class="fc" id="L229">    } catch (IOException e) {</span>
      // ignore
<span class="fc" id="L231">    }</span>
<span class="fc" id="L232">  }</span>

  boolean hasSocketFile(int port) {
<span class="fc" id="L235">    return getFile(port).exists();</span>
  }

  @Override
  public void close() throws RemoteException {
<span class="fc" id="L240">    credentials = null;</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">    if (rmiService != null) {</span>
<span class="fc" id="L243">      rmiService.openPorts().forEach((int port) -&gt; {</span>
<span class="fc" id="L244">        deleteSocketFile(port);</span>
<span class="fc" id="L245">      });</span>
    }
<span class="fc" id="L247">  }</span>

  private AFUNIXRMIService getRmiService() throws IOException {
<span class="fc bfc" id="L250" title="All 2 branches covered.">    if (rmiService == null) {</span>
      try {
<span class="fc" id="L252">        rmiService = naming.getRMIService();</span>
<span class="nc" id="L253">      } catch (NotBoundException e) {</span>
<span class="nc" id="L254">        throw (IOException) new IOException(e.getMessage()).initCause(e);</span>
<span class="fc" id="L255">      }</span>
    }
<span class="fc" id="L257">    return rmiService;</span>
  }

  protected int newPort() throws IOException {
<span class="fc" id="L261">    return getRmiService().newPort();</span>
  }

  protected void returnPort(int port) throws IOException {
<span class="fc" id="L265">    deleteSocketFile(port);</span>
<span class="fc" id="L266">    getRmiService().returnPort(port);</span>
<span class="fc" id="L267">  }</span>

  @SuppressWarnings(&quot;resource&quot;)
  @Override
  public ServerSocket createServerSocket(int port) throws IOException {
<span class="fc bfc" id="L272" title="All 2 branches covered.">    if (port == 0) {</span>
<span class="fc" id="L273">      port = newPort();</span>
<span class="fc" id="L274">      final AFUNIXSocketAddress addr = new AFUNIXSocketAddress(getFile(port), port);</span>
<span class="fc" id="L275">      final AnonymousServerSocket ass = new AnonymousServerSocket(port);</span>
<span class="fc" id="L276">      ass.bind(addr);</span>

<span class="pc bpc" id="L278" title="1 of 2 branches missed.">      if (port &gt;= AFUNIXRMIPorts.AF_PORT_BASE) {</span>
<span class="fc" id="L279">        ass.addCloseable(new PortCloseable(port - AFUNIXRMIPorts.AF_PORT_BASE));</span>
      }
<span class="fc" id="L281">      return ass;</span>
    }

<span class="fc" id="L284">    final RMIServerSocketFactory sf = defaultServerFactory;</span>
<span class="pc bpc" id="L285" title="3 of 4 branches missed.">    if (sf != null &amp;&amp; port &lt; AFUNIXRMIPorts.AF_PORT_BASE) {</span>
<span class="nc" id="L286">      return sf.createServerSocket(port);</span>
    }

<span class="fc" id="L289">    final AFUNIXSocketAddress addr = new AFUNIXSocketAddress(getFile(port), port);</span>
<span class="fc" id="L290">    AFUNIXServerSocket socket = AFUNIXServerSocket.bindOn(addr);</span>
<span class="fc" id="L291">    socket.addCloseable(new PortCloseable(port - AFUNIXRMIPorts.AF_PORT_BASE));</span>
<span class="fc" id="L292">    return socket;</span>
  }

  private final class PortCloseable implements Closeable {
    private final int port;

<span class="fc" id="L298">    private PortCloseable(int port) {</span>
<span class="fc" id="L299">      synchronized (openServerPorts) {</span>
<span class="fc" id="L300">        openServerPorts.set(port);</span>
<span class="fc" id="L301">      }</span>
<span class="fc" id="L302">      this.port = port;</span>
<span class="fc" id="L303">    }</span>

    @Override
    public void close() throws IOException {
<span class="fc" id="L307">      synchronized (openServerPorts) {</span>
<span class="fc" id="L308">        openServerPorts.clear(port);</span>
<span class="fc" id="L309">      }</span>
<span class="fc" id="L310">    }</span>
  }

  @Override
  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
<span class="fc" id="L315">    socketDir = new File(in.readUTF());</span>
<span class="fc" id="L316">    int port = in.readInt();</span>
<span class="fc" id="L317">    naming = AFUNIXNaming.getInstance(socketDir, port);</span>

<span class="fc" id="L319">    defaultClientFactory = (RMIClientSocketFactory) in.readObject();</span>
<span class="fc" id="L320">    defaultServerFactory = (RMIServerSocketFactory) in.readObject();</span>

<span class="fc" id="L322">    socketPrefix = in.readUTF();</span>
<span class="fc" id="L323">    socketSuffix = in.readUTF();</span>
<span class="fc" id="L324">  }</span>

  @Override
  public void writeExternal(ObjectOutput out) throws IOException {
<span class="fc" id="L328">    out.writeUTF(socketDir.getAbsolutePath());</span>
<span class="fc" id="L329">    out.writeInt(naming.getRegistryPort());</span>

<span class="fc" id="L331">    out.writeObject(defaultClientFactory);</span>
<span class="fc" id="L332">    out.writeObject(defaultServerFactory);</span>

<span class="fc" id="L334">    out.writeUTF(socketPrefix);</span>
<span class="fc" id="L335">    out.writeUTF(socketSuffix);</span>
<span class="fc" id="L336">  }</span>

  private final class AnonymousServerSocket extends AFUNIXServerSocket {
    private final int returnPort;

<span class="fc" id="L341">    protected AnonymousServerSocket(int returnPort) throws IOException {</span>
<span class="fc" id="L342">      super();</span>
<span class="fc" id="L343">      this.returnPort = returnPort;</span>
<span class="fc" id="L344">      setReuseAddress(true);</span>
<span class="fc" id="L345">    }</span>

    @Override
    public void close() throws IOException {
<span class="fc" id="L349">      super.close();</span>
<span class="fc" id="L350">      returnPort(returnPort);</span>
<span class="fc" id="L351">    }</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L356">    return super.toString() + //</span>
        &quot;[path=&quot; + socketDir + //
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        (isPlainFileSocket() ? &quot;&quot; : //</span>
<span class="fc" id="L359">            &quot;;prefix=&quot; + socketPrefix + &quot;;suffix=&quot; + socketSuffix) + &quot;]&quot;;</span>
  }

  @Override
  public void onRuntimeShutdown(Thread thread) {
<span class="pc bpc" id="L364" title="2 of 4 branches missed.">    if (thread != Thread.currentThread() || !(thread instanceof ShutdownThread)) {</span>
<span class="nc" id="L365">      throw new IllegalStateException(&quot;Illegal caller&quot;);</span>
    }
    try {
<span class="fc" id="L368">      close();</span>
<span class="nc" id="L369">    } catch (IOException e) {</span>
      // ignore
<span class="fc" id="L371">    }</span>
<span class="fc" id="L372">  }</span>

  AFUNIXSocketCredentials peerCredentialsFor(RemotePeerInfo data) {
<span class="fc" id="L375">    synchronized (credentials) {</span>
<span class="fc" id="L376">      return credentials.get(new HostAndPort(data.host, data.port));</span>
    }
  }

  private static final class HostAndPort {
    final String hostname;
    final int port;

<span class="fc" id="L384">    private HostAndPort(String hostname, int port) {</span>
<span class="fc" id="L385">      this.hostname = hostname;</span>
<span class="fc" id="L386">      this.port = port;</span>
<span class="fc" id="L387">    }</span>

    @Override
    public int hashCode() {
<span class="fc" id="L391">      final int prime = 31;</span>
<span class="fc" id="L392">      int result = 1;</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">      result = prime * result + ((hostname == null) ? 0 : hostname.hashCode());</span>
<span class="fc" id="L394">      result = prime * result + port;</span>
<span class="fc" id="L395">      return result;</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">      if (this == obj) {</span>
<span class="nc" id="L401">        return true;</span>
      }
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">      if (!(obj instanceof HostAndPort)) {</span>
<span class="nc" id="L404">        return false;</span>
      }
<span class="fc" id="L406">      HostAndPort other = (HostAndPort) obj;</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">      if (hostname == null) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (other.hostname != null) {</span>
<span class="nc" id="L409">          return false;</span>
        }
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">      } else if (!hostname.equals(other.hostname)) {</span>
<span class="nc" id="L412">        return false;</span>
      }

<span class="pc bpc" id="L415" title="1 of 2 branches missed.">      return port == other.port;</span>
    }
  }

  public boolean isLocalServer(int port) {
<span class="nc bnc" id="L420" title="All 2 branches missed.">    if (port &lt; AFUNIXRMIPorts.AF_PORT_BASE) {</span>
<span class="nc" id="L421">      return false;</span>
    }
<span class="nc" id="L423">    synchronized (openServerPorts) {</span>
<span class="nc" id="L424">      return openServerPorts.get(port - AFUNIXRMIPorts.AF_PORT_BASE);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>